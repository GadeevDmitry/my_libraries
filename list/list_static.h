/** @file */
#ifndef LIST_STATIC_H
#define LIST_STATIC_H

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "list_settings.h"
#include "list.h"

//================================================================================================================================
// DSL
//================================================================================================================================

//--------------------------------------------------------------------------------------------------------------------------------
// list_node
//--------------------------------------------------------------------------------------------------------------------------------

#define $prev       (lst_node->prev)
#define $next       (lst_node->next)

//--------------------------------------------------------------------------------------------------------------------------------
// list
//--------------------------------------------------------------------------------------------------------------------------------

#define $fictional  (lst->fictional)

#define $size       (lst->size)
#define $el_size    (lst->el_size)

#define $el_dtor    (lst->el_dtor)
#define $el_dump    (lst->el_dump)

//================================================================================================================================
// GLOBAL
//================================================================================================================================

/**
*   @brief Типы ошибок в листе
*/
enum LST_STATUS
{
    LST_OK                  ,   ///< OK
    LST_NULLPTR             ,   ///< lst = nullptr

    LST_POISON_FICTIONAL    ,   ///< .fictional = LST_POISON.fictional
    LST_POISON_SIZE         ,   ///< .size      = LST_POISON.size
    LST_POISON_EL_SIZE      ,   ///< .el_size   = LST_POISON.el_size
    LST_POISON_EL_DTOR      ,   ///< .el_dtor   = LST_POISON.el_dtor
    LST_POISON_EL_DUMP      ,   ///< .el_dump   = LST_POISON.el_dump

    LST_NULLPTR_FICTIONAL   ,   ///< .fictional = nullptr

    LST_INVALID_NODE        ,   ///< .prev = nullpttr || .next = nullptr
    LST_INVALID_CYCLE       ,   ///< нарушен цикл
};

/**
*   @brief Сообщения дл каждого типа ошибок
*
*   @see enum LST_STATUS
*/
static const char *LST_STATUS_MESSAGES[] = 
{
    "list is OK"                ,
    "list is nullptr"           ,

    "list.fictional is poison"  ,
    "list.size"   " is poison"  ,
    "list.el_size"" is poison"  ,
    "list.el_dtor"" is poison"  ,
    "list.el_dump"" is poison"  ,

    "list.fictional is invalid" ,

    "list node"   " is invalid" ,
    "list cycle"  " is invalid" ,
};

/**
*   @brief POISON-значения полей листа
*/
static const list LST_POISON =
{
    (list_node *) 0xDEADBEEF, // fictioanal

    -1UL                    , // size
    -1UL                    , // el_size

    (void (*)(      void *)) 0xABADBABE, // el_dtor
    (void (*)(const void *)) 0xABADB002, // el_dump
};

//================================================================================================================================
// FUNCTION DECLARATION
//================================================================================================================================

//--------------------------------------------------------------------------------------------------------------------------------
// list verify
//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Выводит сообщения об ошибках в листе по битовой маске ошибок. Полный дамп листа.
*/
static void list_log_error(const list *const lst, const unsigned err);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Верификатор полей листа.
*
*   @return битовая маска кодов ошибок из enum LST_STATUS
*
*   @see enum LST_STATUS
*/
static unsigned list_fields_verify(const list *const lst);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Верификатор элементов листа и цикла из них.
*
*   @return битовая маска кодов ошибок из enum LST_STATUS
*
*   @see enum LST_STATUS
*/
static unsigned list_cycle_verify(const list *const lst);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Верификатор полей вершины листа.
*
*   @return битовая маска кодов ошибок из enum LST_STATUS
*
*   @see enum LST_STATUS
*/
static unsigned _list_node_verify(const list_node *const lst_node);

//--------------------------------------------------------------------------------------------------------------------------------
// ctor
//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Конструктор поля .fictional листа.
*/
static bool list_fictional_ctor(list *const lst);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Создает вершину, добавляет ее в цикл
*
*   @param lst  [in, out] - указатель на лист, к которому относится создаваемая вершина
*   @param data [in]      - указатель, откуда скопировать содержимое нового элемента
*   @param prev [in]      - указатель на предыдущую вершину в цикле
*   @param next [in]      - указатель на следующую вершину в цикле
*
*   @return true, если все ОК, false в случае ошибки
*/
static bool list_node_new(list *const lst, const void      *const data,
                                           const list_node *const prev,
                                           const list_node *const next);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Вставляет созданную вершину в цикл, инициализируя ее поля и обновляя поля смежных вершин
*
*   @param lst [in, out] - указатель на лист, к которому относится созданная вершина
*   @param lst_node [in] - созданная вершина листа
*   @param data     [in] - указатель, откуда скопировать содержимое нового элемента
*   @param prev     [in] - указатель на предыдущую вершину в цикле
*   @param next     [in] - указатель на следующую вершину в цикле
*/
static void list_node_ctor(list      *const lst,
                           list_node *const lst_node,   const void      *const data,
                                                        const list_node *const prev,
                                                        const list_node *const next);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Удаляет вершину, обновляет поля смежных в цикле вершин, чтобы связность не нарушилась.
*
*   @param lst     [in, out] - указатель на лист, к которому относится удаляемая вершина
*   @param lst_node    [in]  - удаляемая вершина листа
*   @param erased_data [out] - указатель, по которому скопировать содержимое удаляемой вершины (nullptr, если копировать не надо)
*/
static bool list_node_delete(list      *const lst,
                             list_node *const lst_node, void *const erased_data);

//--------------------------------------------------------------------------------------------------------------------------------
// dtor
//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Деструктор пользовательских данных листа.
*/
static void list_fictional_dtor(list *const lst);

//--------------------------------------------------------------------------------------------------------------------------------
// insert erase
//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Возвращает указатель на вершину листа.
*
*   @param lst      [in] - указатель на лист
*   @param index    [in] - порядковый номер вершины листа
*
*   @return указатель на вершину листа с порядковым номером index
*/
static list_node *list_get_node(const list *const lst, const size_t index);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Возвращает позицию элемента в листе.
*
*   @param lst      [in] - указатель на лист
*   @param target   [in] - указатель на элемент, который нужно найти
*   @param elem_cmp [in] - указатель на функцию сравнения элементов, которая возвращает 0, если элементы равны
*
*   @return порядковый номер элемента в листе
*/
static size_t list_find_pos(const list *const lst, const void *const target, int (*el_cmp)(const void *el_1, const void *el_2));

//--------------------------------------------------------------------------------------------------------------------------------
// dump
//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Дамп листа.
*   В "полном" режиме (is_full = true), помимо пользовательских данных, дампит и служебные. Используется для дампа невалидного листа.
*
*   @param lst     [in] - указатель на лист
*   @param is_full [in] - true, если нужен дамп со служебной информацией, false иначе
*/
static void list_static_dump(const list *const lst, const bool is_full);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief "Шапка" дампа листа.
*
*   @return true, если lst != nullptr
*/
static __always_inline bool list_header_dump(const list *const lst);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Дамп "public" полей кэш-листа.
*
*   @return true, если хоть одно поле невалидно
*/
static bool list_public_fields_dump(const list *const lst);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Дамп "static" полей кэш-листа.
*
*   @return true, если хоть одно поле невалидно
*/
static bool list_static_fields_dump(const list *const lst);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief Дамп содержимого листа.
*
*   @param lst            [in] - указатель на кеш-лист для дампа
*   @param is_full        [in] - true, если нужен дамп "static" полей
*   @param is_any_invalid [in] - true, если хоть одно поле невалидно
*/
static void list_data_dump(const list *const lst, const bool is_full,
                                                  const bool is_any_invalid);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief "Debug" дамп содержимого листа.
*   Дамп содержит поля структур list_node, помимо пользовательских данных.
*/
static void list_data_debug_dump(const list *const lst);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief "Debug" дамп вершины листа.
*   Дамп полей вершины, пользовательского элемента.
*/
static void list_node_debug_dump(const list *const lst, const list_node *const lst_node);

//--------------------------------------------------------------------------------------------------------------------------------

/**
*   @brief "Pretty" дамп содержимого листа.
*   Дамп только пользовательских данных.
*/
static void list_data_pretty_dump(const list *const lst);

#endif //LIST_STATIC_H
